Index: src/msw/bitmap.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/msw/bitmap.cpp,v
retrieving revision 1.132
retrieving revision 1.133
diff -u -2 -r1.132 -r1.133
--- src/msw/bitmap.cpp	2005/05/31 23:53:09	1.132
+++ src/msw/bitmap.cpp	2005/06/13 12:19:28	1.133
@@ -906,5 +906,5 @@
         }
 
-        delete data;
+        delete[] data;
     }
 
@@ -1251,5 +1251,5 @@
     if ( !GetBitmapData()->m_isDIB )
     {
-        wxCHECK_MSG( !GetBitmapData()->m_dib, FALSE,
+        wxCHECK_MSG( !GetBitmapData()->m_dib, NULL,
                         _T("GetRawData() may be called only once") );
 
@@ -1600,5 +1600,5 @@
    lpDIBheader->bmiHeader.biBitCount = (WORD)(bitsPerPixel);
    lpDIBheader->bmiHeader.biCompression = BI_RGB;
-   lpDIBheader->bmiHeader.biSizeImage = xSize * abs(ySize) * bitsPerPixel >> 3;
+   lpDIBheader->bmiHeader.biSizeImage = (xSize * abs(ySize) * bitsPerPixel) >> 3;
    lpDIBheader->bmiHeader.biClrUsed = 256;
 
Index: src/msw/dib.cpp
===================================================================
RCS file: /pack/cvsroots/wxwidgets/wxWidgets/src/msw/dib.cpp,v
retrieving revision 1.59
retrieving revision 1.60
diff -u -2 -r1.59 -r1.60
--- src/msw/dib.cpp	2005/04/23 18:59:30	1.59
+++ src/msw/dib.cpp	2005/06/21 20:17:42	1.60
@@ -395,5 +395,29 @@
     }
 
-    return ConvertToBitmap((BITMAPINFO *)&ds.dsBmih, hdc, ds.dsBm.bmBits);
+    // how many colours are we going to have in the palette?
+    DWORD biClrUsed = ds.dsBmih.biClrUsed;
+    if ( !biClrUsed )
+    {
+        // biClrUsed field might not be set
+        biClrUsed = GetNumberOfColours(ds.dsBmih.biBitCount);
+    }
+
+    if ( !biClrUsed )
+    {
+        return ConvertToBitmap((BITMAPINFO *)&ds.dsBmih, hdc, ds.dsBm.bmBits);
+    }
+    else
+    {
+        // fake a BITMAPINFO w/o bits, just the palette info
+        wxCharBuffer bmi(sizeof(BITMAPINFO) + (biClrUsed - 1)*sizeof(RGBQUAD));
+        BITMAPINFO *pBmi = (BITMAPINFO *)bmi.data();
+        MemoryHDC hDC;
+        // get the colour table
+        SelectInHDC sDC(hDC, m_handle);
+        ::GetDIBColorTable(hDC, 0, biClrUsed, pBmi->bmiColors);
+        memcpy(&pBmi->bmiHeader, &ds.dsBmih, ds.dsBmih.biSize);
+
+        return ConvertToBitmap(pBmi, hdc, ds.dsBm.bmBits);
+    }
 }
 
@@ -592,4 +616,6 @@
     }
 
+    MemoryHDC hDC;
+
     // LOGPALETTE struct has only 1 element in palPalEntry array, we're
     // going to have biClrUsed of them so add necessary space
@@ -602,6 +628,9 @@
     pPalette->palNumEntries = (WORD)biClrUsed;
 
-    // and the colour table (it starts right after the end of the header)
-    const RGBQUAD *pRGB = (RGBQUAD *)((char *)&ds.dsBmih + ds.dsBmih.biSize);
+    // and the colour table
+    wxCharBuffer rgb(sizeof(RGBQUAD) * biClrUsed);
+    RGBQUAD *pRGB = (RGBQUAD*)rgb.data();
+    SelectInHDC(hDC, m_handle);
+    ::GetDIBColorTable(hDC, 0, biClrUsed, pRGB);
     for ( DWORD i = 0; i < biClrUsed; i++, pRGB++ )
     {
